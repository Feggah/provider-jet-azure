/*
Copyright 2020 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type ClusterKeyObservation struct {
}

type ClusterKeyParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	OrderBy *string `json:"orderBy" tf:"order_by,omitempty"`
}

type ColumnObservation struct {
}

type ColumnParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Type *string `json:"type" tf:"type,omitempty"`
}

type CosmosdbCassandraTableAutoscaleSettingsObservation struct {
}

type CosmosdbCassandraTableAutoscaleSettingsParameters struct {

	// +kubebuilder:validation:Optional
	MaxThroughput *int64 `json:"maxThroughput,omitempty" tf:"max_throughput,omitempty"`
}

type CosmosdbCassandraTableObservation struct {
}

type CosmosdbCassandraTableParameters struct {

	// +kubebuilder:validation:Optional
	AnalyticalStorageTTL *int64 `json:"analyticalStorageTtl,omitempty" tf:"analytical_storage_ttl,omitempty"`

	// +kubebuilder:validation:Optional
	AutoscaleSettings []CosmosdbCassandraTableAutoscaleSettingsParameters `json:"autoscaleSettings,omitempty" tf:"autoscale_settings,omitempty"`

	// +crossplane:generate:reference:type=CosmosdbCassandraKeyspace
	// +kubebuilder:validation:Optional
	CassandraKeyspaceID *string `json:"cassandraKeyspaceId,omitempty" tf:"cassandra_keyspace_id,omitempty"`

	// +kubebuilder:validation:Optional
	CassandraKeyspaceIDRef *v1.Reference `json:"cassandraKeyspaceIdRef,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	CassandraKeyspaceIDSelector *v1.Selector `json:"cassandraKeyspaceIdSelector,omitempty" tf:"-"`

	// +kubebuilder:validation:Optional
	DefaultTTL *int64 `json:"defaultTtl,omitempty" tf:"default_ttl,omitempty"`

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`

	// +kubebuilder:validation:Required
	Schema []SchemaParameters `json:"schema" tf:"schema,omitempty"`

	// +kubebuilder:validation:Optional
	Throughput *int64 `json:"throughput,omitempty" tf:"throughput,omitempty"`
}

type PartitionKeyObservation struct {
}

type PartitionKeyParameters struct {

	// +kubebuilder:validation:Required
	Name *string `json:"name" tf:"name,omitempty"`
}

type SchemaObservation struct {
}

type SchemaParameters struct {

	// +kubebuilder:validation:Optional
	ClusterKey []ClusterKeyParameters `json:"clusterKey,omitempty" tf:"cluster_key,omitempty"`

	// +kubebuilder:validation:Required
	Column []ColumnParameters `json:"column" tf:"column,omitempty"`

	// +kubebuilder:validation:Required
	PartitionKey []PartitionKeyParameters `json:"partitionKey" tf:"partition_key,omitempty"`
}

// CosmosdbCassandraTableSpec defines the desired state of CosmosdbCassandraTable
type CosmosdbCassandraTableSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     CosmosdbCassandraTableParameters `json:"forProvider"`
}

// CosmosdbCassandraTableStatus defines the observed state of CosmosdbCassandraTable.
type CosmosdbCassandraTableStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        CosmosdbCassandraTableObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// CosmosdbCassandraTable is the Schema for the CosmosdbCassandraTables API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azure}
type CosmosdbCassandraTable struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              CosmosdbCassandraTableSpec   `json:"spec"`
	Status            CosmosdbCassandraTableStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// CosmosdbCassandraTableList contains a list of CosmosdbCassandraTables
type CosmosdbCassandraTableList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []CosmosdbCassandraTable `json:"items"`
}

// Repository type metadata.
var (
	CosmosdbCassandraTableKind             = "CosmosdbCassandraTable"
	CosmosdbCassandraTableGroupKind        = schema.GroupKind{Group: Group, Kind: CosmosdbCassandraTableKind}.String()
	CosmosdbCassandraTableKindAPIVersion   = CosmosdbCassandraTableKind + "." + GroupVersion.String()
	CosmosdbCassandraTableGroupVersionKind = GroupVersion.WithKind(CosmosdbCassandraTableKind)
)

func init() {
	SchemeBuilder.Register(&CosmosdbCassandraTable{}, &CosmosdbCassandraTableList{})
}
