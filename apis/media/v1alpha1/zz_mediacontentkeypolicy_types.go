/*
Copyright 2020 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type FairplayConfigurationObservation struct {
}

type FairplayConfigurationParameters struct {
	Ask *string `json:"ask,omitempty" tf:"ask"`

	OfflineRentalConfiguration []OfflineRentalConfigurationParameters `json:"offlineRentalConfiguration,omitempty" tf:"offline_rental_configuration"`

	Pfx *string `json:"pfx,omitempty" tf:"pfx"`

	PfxPassword *string `json:"pfxPassword,omitempty" tf:"pfx_password"`

	RentalAndLeaseKeyType *string `json:"rentalAndLeaseKeyType,omitempty" tf:"rental_and_lease_key_type"`

	RentalDurationSeconds *int64 `json:"rentalDurationSeconds,omitempty" tf:"rental_duration_seconds"`
}

type MediaContentKeyPolicyObservation struct {
}

type MediaContentKeyPolicyParameters struct {
	Description *string `json:"description,omitempty" tf:"description"`

	MediaServicesAccountName string `json:"mediaServicesAccountName" tf:"media_services_account_name"`

	Name string `json:"name" tf:"name"`

	PolicyOption []PolicyOptionParameters `json:"policyOption" tf:"policy_option"`

	ResourceGroupName string `json:"resourceGroupName" tf:"resource_group_name"`
}

type OfflineRentalConfigurationObservation struct {
}

type OfflineRentalConfigurationParameters struct {
	PlaybackDurationSeconds *int64 `json:"playbackDurationSeconds,omitempty" tf:"playback_duration_seconds"`

	StorageDurationSeconds *int64 `json:"storageDurationSeconds,omitempty" tf:"storage_duration_seconds"`
}

type PlayRightObservation struct {
}

type PlayRightParameters struct {
	AgcAndColorStripeRestriction *int64 `json:"agcAndColorStripeRestriction,omitempty" tf:"agc_and_color_stripe_restriction"`

	AllowPassingVideoContentToUnknownOutput *string `json:"allowPassingVideoContentToUnknownOutput,omitempty" tf:"allow_passing_video_content_to_unknown_output"`

	AnalogVideoOpl *int64 `json:"analogVideoOpl,omitempty" tf:"analog_video_opl"`

	CompressedDigitalAudioOpl *int64 `json:"compressedDigitalAudioOpl,omitempty" tf:"compressed_digital_audio_opl"`

	DigitalVideoOnlyContentRestriction *bool `json:"digitalVideoOnlyContentRestriction,omitempty" tf:"digital_video_only_content_restriction"`

	FirstPlayExpiration *string `json:"firstPlayExpiration,omitempty" tf:"first_play_expiration"`

	ImageConstraintForAnalogComponentVideoRestriction *bool `json:"imageConstraintForAnalogComponentVideoRestriction,omitempty" tf:"image_constraint_for_analog_component_video_restriction"`

	ImageConstraintForAnalogComputerMonitorRestriction *bool `json:"imageConstraintForAnalogComputerMonitorRestriction,omitempty" tf:"image_constraint_for_analog_computer_monitor_restriction"`

	ScmsRestriction *int64 `json:"scmsRestriction,omitempty" tf:"scms_restriction"`

	UncompressedDigitalAudioOpl *int64 `json:"uncompressedDigitalAudioOpl,omitempty" tf:"uncompressed_digital_audio_opl"`

	UncompressedDigitalVideoOpl *int64 `json:"uncompressedDigitalVideoOpl,omitempty" tf:"uncompressed_digital_video_opl"`
}

type PlayreadyConfigurationLicenseObservation struct {
}

type PlayreadyConfigurationLicenseParameters struct {
	AllowTestDevices *bool `json:"allowTestDevices,omitempty" tf:"allow_test_devices"`

	BeginDate *string `json:"beginDate,omitempty" tf:"begin_date"`

	ContentKeyLocationFromHeaderEnabled *bool `json:"contentKeyLocationFromHeaderEnabled,omitempty" tf:"content_key_location_from_header_enabled"`

	ContentKeyLocationFromKeyId *string `json:"contentKeyLocationFromKeyId,omitempty" tf:"content_key_location_from_key_id"`

	ContentType *string `json:"contentType,omitempty" tf:"content_type"`

	ExpirationDate *string `json:"expirationDate,omitempty" tf:"expiration_date"`

	GracePeriod *string `json:"gracePeriod,omitempty" tf:"grace_period"`

	LicenseType *string `json:"licenseType,omitempty" tf:"license_type"`

	PlayRight []PlayRightParameters `json:"playRight,omitempty" tf:"play_right"`

	RelativeBeginDate *string `json:"relativeBeginDate,omitempty" tf:"relative_begin_date"`

	RelativeExpirationDate *string `json:"relativeExpirationDate,omitempty" tf:"relative_expiration_date"`
}

type PolicyOptionObservation struct {
}

type PolicyOptionParameters struct {
	ClearKeyConfigurationEnabled *bool `json:"clearKeyConfigurationEnabled,omitempty" tf:"clear_key_configuration_enabled"`

	FairplayConfiguration []FairplayConfigurationParameters `json:"fairplayConfiguration,omitempty" tf:"fairplay_configuration"`

	Name string `json:"name" tf:"name"`

	OpenRestrictionEnabled *bool `json:"openRestrictionEnabled,omitempty" tf:"open_restriction_enabled"`

	PlayreadyConfigurationLicense []PlayreadyConfigurationLicenseParameters `json:"playreadyConfigurationLicense,omitempty" tf:"playready_configuration_license"`

	TokenRestriction []TokenRestrictionParameters `json:"tokenRestriction,omitempty" tf:"token_restriction"`

	WidevineConfigurationTemplate *string `json:"widevineConfigurationTemplate,omitempty" tf:"widevine_configuration_template"`
}

type RequiredClaimObservation struct {
}

type RequiredClaimParameters struct {
	Type *string `json:"type,omitempty" tf:"type"`

	Value *string `json:"value,omitempty" tf:"value"`
}

type TokenRestrictionObservation struct {
}

type TokenRestrictionParameters struct {
	Audience *string `json:"audience,omitempty" tf:"audience"`

	Issuer *string `json:"issuer,omitempty" tf:"issuer"`

	OpenIdConnectDiscoveryDocument *string `json:"openIdConnectDiscoveryDocument,omitempty" tf:"open_id_connect_discovery_document"`

	PrimaryRsaTokenKeyExponent *string `json:"primaryRsaTokenKeyExponent,omitempty" tf:"primary_rsa_token_key_exponent"`

	PrimaryRsaTokenKeyModulus *string `json:"primaryRsaTokenKeyModulus,omitempty" tf:"primary_rsa_token_key_modulus"`

	PrimarySymmetricTokenKey *string `json:"primarySymmetricTokenKey,omitempty" tf:"primary_symmetric_token_key"`

	PrimaryX509TokenKeyRaw *string `json:"primaryX509TokenKeyRaw,omitempty" tf:"primary_x509_token_key_raw"`

	RequiredClaim []RequiredClaimParameters `json:"requiredClaim,omitempty" tf:"required_claim"`

	TokenType *string `json:"tokenType,omitempty" tf:"token_type"`
}

// MediaContentKeyPolicySpec defines the desired state of MediaContentKeyPolicy
type MediaContentKeyPolicySpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       MediaContentKeyPolicyParameters `json:"forProvider"`
}

// MediaContentKeyPolicyStatus defines the observed state of MediaContentKeyPolicy.
type MediaContentKeyPolicyStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          MediaContentKeyPolicyObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// MediaContentKeyPolicy is the Schema for the MediaContentKeyPolicys API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azure}
type MediaContentKeyPolicy struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MediaContentKeyPolicySpec   `json:"spec"`
	Status            MediaContentKeyPolicyStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MediaContentKeyPolicyList contains a list of MediaContentKeyPolicys
type MediaContentKeyPolicyList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []MediaContentKeyPolicy `json:"items"`
}

// Repository type metadata.
var (
	MediaContentKeyPolicyKind             = "MediaContentKeyPolicy"
	MediaContentKeyPolicyGroupKind        = schema.GroupKind{Group: Group, Kind: MediaContentKeyPolicyKind}.String()
	MediaContentKeyPolicyKindAPIVersion   = MediaContentKeyPolicyKind + "." + GroupVersion.String()
	MediaContentKeyPolicyGroupVersionKind = GroupVersion.WithKind(MediaContentKeyPolicyKind)
)

func init() {
	SchemeBuilder.Register(&MediaContentKeyPolicy{}, &MediaContentKeyPolicyList{})
}
