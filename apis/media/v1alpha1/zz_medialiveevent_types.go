/*
Copyright 2020 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type CrossSiteAccessPolicyObservation struct {
}

type CrossSiteAccessPolicyParameters struct {
	ClientAccessPolicy *string `json:"clientAccessPolicy,omitempty" tf:"client_access_policy"`

	CrossDomainPolicy *string `json:"crossDomainPolicy,omitempty" tf:"cross_domain_policy"`
}

type EncodingObservation struct {
}

type EncodingParameters struct {
	KeyFrameInterval *string `json:"keyFrameInterval,omitempty" tf:"key_frame_interval"`

	PresetName *string `json:"presetName,omitempty" tf:"preset_name"`

	StretchMode *string `json:"stretchMode,omitempty" tf:"stretch_mode"`

	Type *string `json:"type,omitempty" tf:"type"`
}

type EndpointObservation struct {
	Protocol string `json:"protocol" tf:"protocol"`

	URL string `json:"url" tf:"url"`
}

type EndpointParameters struct {
}

type IPAccessControlAllowObservation struct {
}

type IPAccessControlAllowParameters struct {
	Address *string `json:"address,omitempty" tf:"address"`

	Name *string `json:"name,omitempty" tf:"name"`

	SubnetPrefixLength *int64 `json:"subnetPrefixLength,omitempty" tf:"subnet_prefix_length"`
}

type InputObservation struct {
	Endpoint []EndpointObservation `json:"endpoint" tf:"endpoint"`
}

type InputParameters struct {
	AccessToken *string `json:"accessToken,omitempty" tf:"access_token"`

	IPAccessControlAllow []IPAccessControlAllowParameters `json:"ipAccessControlAllow,omitempty" tf:"ip_access_control_allow"`

	KeyFrameIntervalDuration *string `json:"keyFrameIntervalDuration,omitempty" tf:"key_frame_interval_duration"`

	StreamingProtocol *string `json:"streamingProtocol,omitempty" tf:"streaming_protocol"`
}

type MediaLiveEventObservation struct {
}

type MediaLiveEventParameters struct {
	AutoStartEnabled *bool `json:"autoStartEnabled,omitempty" tf:"auto_start_enabled"`

	CrossSiteAccessPolicy []CrossSiteAccessPolicyParameters `json:"crossSiteAccessPolicy,omitempty" tf:"cross_site_access_policy"`

	Description *string `json:"description,omitempty" tf:"description"`

	Encoding []EncodingParameters `json:"encoding,omitempty" tf:"encoding"`

	HostnamePrefix *string `json:"hostnamePrefix,omitempty" tf:"hostname_prefix"`

	Input []InputParameters `json:"input" tf:"input"`

	Location string `json:"location" tf:"location"`

	MediaServicesAccountName string `json:"mediaServicesAccountName" tf:"media_services_account_name"`

	Name string `json:"name" tf:"name"`

	Preview []PreviewParameters `json:"preview,omitempty" tf:"preview"`

	ResourceGroupName string `json:"resourceGroupName" tf:"resource_group_name"`

	Tags map[string]string `json:"tags,omitempty" tf:"tags"`

	TranscriptionLanguages []string `json:"transcriptionLanguages,omitempty" tf:"transcription_languages"`

	UseStaticHostname *bool `json:"useStaticHostname,omitempty" tf:"use_static_hostname"`
}

type PreviewEndpointObservation struct {
	Protocol string `json:"protocol" tf:"protocol"`

	URL string `json:"url" tf:"url"`
}

type PreviewEndpointParameters struct {
}

type PreviewIPAccessControlAllowObservation struct {
}

type PreviewIPAccessControlAllowParameters struct {
	Address *string `json:"address,omitempty" tf:"address"`

	Name *string `json:"name,omitempty" tf:"name"`

	SubnetPrefixLength *int64 `json:"subnetPrefixLength,omitempty" tf:"subnet_prefix_length"`
}

type PreviewObservation struct {
	Endpoint []PreviewEndpointObservation `json:"endpoint" tf:"endpoint"`
}

type PreviewParameters struct {
	AlternativeMediaID *string `json:"alternativeMediaId,omitempty" tf:"alternative_media_id"`

	IPAccessControlAllow []PreviewIPAccessControlAllowParameters `json:"ipAccessControlAllow,omitempty" tf:"ip_access_control_allow"`

	PreviewLocator *string `json:"previewLocator,omitempty" tf:"preview_locator"`

	StreamingPolicyName *string `json:"streamingPolicyName,omitempty" tf:"streaming_policy_name"`
}

// MediaLiveEventSpec defines the desired state of MediaLiveEvent
type MediaLiveEventSpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       MediaLiveEventParameters `json:"forProvider"`
}

// MediaLiveEventStatus defines the observed state of MediaLiveEvent.
type MediaLiveEventStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          MediaLiveEventObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// MediaLiveEvent is the Schema for the MediaLiveEvents API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azure}
type MediaLiveEvent struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              MediaLiveEventSpec   `json:"spec"`
	Status            MediaLiveEventStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// MediaLiveEventList contains a list of MediaLiveEvents
type MediaLiveEventList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []MediaLiveEvent `json:"items"`
}

// Repository type metadata.
var (
	MediaLiveEventKind             = "MediaLiveEvent"
	MediaLiveEventGroupKind        = schema.GroupKind{Group: Group, Kind: MediaLiveEventKind}.String()
	MediaLiveEventKindAPIVersion   = MediaLiveEventKind + "." + GroupVersion.String()
	MediaLiveEventGroupVersionKind = GroupVersion.WithKind(MediaLiveEventKind)
)

func init() {
	SchemeBuilder.Register(&MediaLiveEvent{}, &MediaLiveEventList{})
}
