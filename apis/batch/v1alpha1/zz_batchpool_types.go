/*
Copyright 2020 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type AutoScaleObservation struct {
}

type AutoScaleParameters struct {
	EvaluationInterval *string `json:"evaluationInterval,omitempty" tf:"evaluation_interval"`

	Formula string `json:"formula" tf:"formula"`
}

type AutoUserObservation struct {
}

type AutoUserParameters struct {
	ElevationLevel *string `json:"elevationLevel,omitempty" tf:"elevation_level"`

	Scope *string `json:"scope,omitempty" tf:"scope"`
}

type BatchPoolObservation struct {
}

type BatchPoolParameters struct {
	AccountName string `json:"accountName" tf:"account_name"`

	AutoScale []AutoScaleParameters `json:"autoScale,omitempty" tf:"auto_scale"`

	Certificate []CertificateParameters `json:"certificate,omitempty" tf:"certificate"`

	ContainerConfiguration []ContainerConfigurationParameters `json:"containerConfiguration,omitempty" tf:"container_configuration"`

	DisplayName *string `json:"displayName,omitempty" tf:"display_name"`

	FixedScale []FixedScaleParameters `json:"fixedScale,omitempty" tf:"fixed_scale"`

	MaxTasksPerNode *int64 `json:"maxTasksPerNode,omitempty" tf:"max_tasks_per_node"`

	Metadata map[string]string `json:"metadata,omitempty" tf:"metadata"`

	Name string `json:"name" tf:"name"`

	NetworkConfiguration []NetworkConfigurationParameters `json:"networkConfiguration,omitempty" tf:"network_configuration"`

	NodeAgentSkuID string `json:"nodeAgentSkuId" tf:"node_agent_sku_id"`

	ResourceGroupName string `json:"resourceGroupName" tf:"resource_group_name"`

	StartTask []StartTaskParameters `json:"startTask,omitempty" tf:"start_task"`

	StopPendingResizeOperation *bool `json:"stopPendingResizeOperation,omitempty" tf:"stop_pending_resize_operation"`

	StorageImageReference []StorageImageReferenceParameters `json:"storageImageReference" tf:"storage_image_reference"`

	VMSize string `json:"vmSize" tf:"vm_size"`
}

type CertificateObservation struct {
}

type CertificateParameters struct {
	ID string `json:"id" tf:"id"`

	StoreLocation string `json:"storeLocation" tf:"store_location"`

	StoreName *string `json:"storeName,omitempty" tf:"store_name"`

	Visibility []string `json:"visibility,omitempty" tf:"visibility"`
}

type ContainerConfigurationObservation struct {
}

type ContainerConfigurationParameters struct {
	ContainerImageNames []string `json:"containerImageNames,omitempty" tf:"container_image_names"`

	ContainerRegistries []ContainerRegistriesParameters `json:"containerRegistries,omitempty" tf:"container_registries"`

	Type *string `json:"type,omitempty" tf:"type"`
}

type ContainerRegistriesObservation struct {
}

type ContainerRegistriesParameters struct {
	Password string `json:"password" tf:"password"`

	RegistryServer string `json:"registryServer" tf:"registry_server"`

	UserName string `json:"userName" tf:"user_name"`
}

type EndpointConfigurationObservation struct {
}

type EndpointConfigurationParameters struct {
	BackendPort int64 `json:"backendPort" tf:"backend_port"`

	FrontendPortRange string `json:"frontendPortRange" tf:"frontend_port_range"`

	Name string `json:"name" tf:"name"`

	NetworkSecurityGroupRules []NetworkSecurityGroupRulesParameters `json:"networkSecurityGroupRules,omitempty" tf:"network_security_group_rules"`

	Protocol string `json:"protocol" tf:"protocol"`
}

type FixedScaleObservation struct {
}

type FixedScaleParameters struct {
	ResizeTimeout *string `json:"resizeTimeout,omitempty" tf:"resize_timeout"`

	TargetDedicatedNodes *int64 `json:"targetDedicatedNodes,omitempty" tf:"target_dedicated_nodes"`

	TargetLowPriorityNodes *int64 `json:"targetLowPriorityNodes,omitempty" tf:"target_low_priority_nodes"`
}

type NetworkConfigurationObservation struct {
}

type NetworkConfigurationParameters struct {
	EndpointConfiguration []EndpointConfigurationParameters `json:"endpointConfiguration,omitempty" tf:"endpoint_configuration"`

	PublicAddressProvisioningType *string `json:"publicAddressProvisioningType,omitempty" tf:"public_address_provisioning_type"`

	PublicIps []string `json:"publicIps,omitempty" tf:"public_ips"`

	SubnetID string `json:"subnetId" tf:"subnet_id"`
}

type NetworkSecurityGroupRulesObservation struct {
}

type NetworkSecurityGroupRulesParameters struct {
	Access string `json:"access" tf:"access"`

	Priority int64 `json:"priority" tf:"priority"`

	SourceAddressPrefix string `json:"sourceAddressPrefix" tf:"source_address_prefix"`
}

type ResourceFileObservation struct {
}

type ResourceFileParameters struct {
	AutoStorageContainerName *string `json:"autoStorageContainerName,omitempty" tf:"auto_storage_container_name"`

	BlobPrefix *string `json:"blobPrefix,omitempty" tf:"blob_prefix"`

	FileMode *string `json:"fileMode,omitempty" tf:"file_mode"`

	FilePath *string `json:"filePath,omitempty" tf:"file_path"`

	HTTPURL *string `json:"httpUrl,omitempty" tf:"http_url"`

	StorageContainerURL *string `json:"storageContainerUrl,omitempty" tf:"storage_container_url"`
}

type StartTaskObservation struct {
}

type StartTaskParameters struct {
	CommandLine string `json:"commandLine" tf:"command_line"`

	Environment map[string]string `json:"environment,omitempty" tf:"environment"`

	MaxTaskRetryCount *int64 `json:"maxTaskRetryCount,omitempty" tf:"max_task_retry_count"`

	ResourceFile []ResourceFileParameters `json:"resourceFile,omitempty" tf:"resource_file"`

	UserIdentity []UserIdentityParameters `json:"userIdentity" tf:"user_identity"`

	WaitForSuccess *bool `json:"waitForSuccess,omitempty" tf:"wait_for_success"`
}

type StorageImageReferenceObservation struct {
}

type StorageImageReferenceParameters struct {
	ID *string `json:"id,omitempty" tf:"id"`

	Offer *string `json:"offer,omitempty" tf:"offer"`

	Publisher *string `json:"publisher,omitempty" tf:"publisher"`

	Sku *string `json:"sku,omitempty" tf:"sku"`

	Version *string `json:"version,omitempty" tf:"version"`
}

type UserIdentityObservation struct {
}

type UserIdentityParameters struct {
	AutoUser []AutoUserParameters `json:"autoUser,omitempty" tf:"auto_user"`

	UserName *string `json:"userName,omitempty" tf:"user_name"`
}

// BatchPoolSpec defines the desired state of BatchPool
type BatchPoolSpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       BatchPoolParameters `json:"forProvider"`
}

// BatchPoolStatus defines the observed state of BatchPool.
type BatchPoolStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          BatchPoolObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// BatchPool is the Schema for the BatchPools API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azure}
type BatchPool struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              BatchPoolSpec   `json:"spec"`
	Status            BatchPoolStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// BatchPoolList contains a list of BatchPools
type BatchPoolList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []BatchPool `json:"items"`
}

// Repository type metadata.
var (
	BatchPoolKind             = "BatchPool"
	BatchPoolGroupKind        = schema.GroupKind{Group: Group, Kind: BatchPoolKind}.String()
	BatchPoolKindAPIVersion   = BatchPoolKind + "." + GroupVersion.String()
	BatchPoolGroupVersionKind = GroupVersion.WithKind(BatchPoolKind)
)

func init() {
	SchemeBuilder.Register(&BatchPool{}, &BatchPoolList{})
}
