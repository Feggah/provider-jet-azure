/*
Copyright 2020 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type DestinationObservation struct {
}

type DestinationParameters struct {
	Address *string `json:"address,omitempty" tf:"address"`

	Port *int64 `json:"port,omitempty" tf:"port"`

	VirtualMachineID *string `json:"virtualMachineId,omitempty" tf:"virtual_machine_id"`
}

type EndpointObservation struct {
}

type EndpointParameters struct {
	Address *string `json:"address,omitempty" tf:"address"`

	CoverageLevel *string `json:"coverageLevel,omitempty" tf:"coverage_level"`

	ExcludedIPAddresses []string `json:"excludedIpAddresses,omitempty" tf:"excluded_ip_addresses"`

	Filter []FilterParameters `json:"filter,omitempty" tf:"filter"`

	IncludedIPAddresses []string `json:"includedIpAddresses,omitempty" tf:"included_ip_addresses"`

	Name string `json:"name" tf:"name"`

	TargetResourceID *string `json:"targetResourceId,omitempty" tf:"target_resource_id"`

	TargetResourceType *string `json:"targetResourceType,omitempty" tf:"target_resource_type"`

	VirtualMachineID *string `json:"virtualMachineId,omitempty" tf:"virtual_machine_id"`
}

type FilterObservation struct {
}

type FilterParameters struct {
	Item []ItemParameters `json:"item,omitempty" tf:"item"`

	Type *string `json:"type,omitempty" tf:"type"`
}

type HTTPConfigurationObservation struct {
}

type HTTPConfigurationParameters struct {
	Method *string `json:"method,omitempty" tf:"method"`

	Path *string `json:"path,omitempty" tf:"path"`

	Port *int64 `json:"port,omitempty" tf:"port"`

	PreferHTTPS *bool `json:"preferHttps,omitempty" tf:"prefer_https"`

	RequestHeader []RequestHeaderParameters `json:"requestHeader,omitempty" tf:"request_header"`

	ValidStatusCodeRanges []string `json:"validStatusCodeRanges,omitempty" tf:"valid_status_code_ranges"`
}

type IcmpConfigurationObservation struct {
}

type IcmpConfigurationParameters struct {
	TraceRouteEnabled *bool `json:"traceRouteEnabled,omitempty" tf:"trace_route_enabled"`
}

type ItemObservation struct {
}

type ItemParameters struct {
	Address *string `json:"address,omitempty" tf:"address"`

	Type *string `json:"type,omitempty" tf:"type"`
}

type NetworkConnectionMonitorObservation struct {
}

type NetworkConnectionMonitorParameters struct {
	AutoStart *bool `json:"autoStart,omitempty" tf:"auto_start"`

	Destination []DestinationParameters `json:"destination,omitempty" tf:"destination"`

	Endpoint []EndpointParameters `json:"endpoint" tf:"endpoint"`

	IntervalInSeconds *int64 `json:"intervalInSeconds,omitempty" tf:"interval_in_seconds"`

	Location string `json:"location" tf:"location"`

	Name string `json:"name" tf:"name"`

	NetworkWatcherID string `json:"networkWatcherId" tf:"network_watcher_id"`

	Notes *string `json:"notes,omitempty" tf:"notes"`

	OutputWorkspaceResourceIds []string `json:"outputWorkspaceResourceIds,omitempty" tf:"output_workspace_resource_ids"`

	Source []SourceParameters `json:"source,omitempty" tf:"source"`

	Tags map[string]string `json:"tags,omitempty" tf:"tags"`

	TestConfiguration []TestConfigurationParameters `json:"testConfiguration" tf:"test_configuration"`

	TestGroup []TestGroupParameters `json:"testGroup" tf:"test_group"`
}

type RequestHeaderObservation struct {
}

type RequestHeaderParameters struct {
	Name string `json:"name" tf:"name"`

	Value string `json:"value" tf:"value"`
}

type SourceObservation struct {
}

type SourceParameters struct {
	Port *int64 `json:"port,omitempty" tf:"port"`

	VirtualMachineID *string `json:"virtualMachineId,omitempty" tf:"virtual_machine_id"`
}

type SuccessThresholdObservation struct {
}

type SuccessThresholdParameters struct {
	ChecksFailedPercent *int64 `json:"checksFailedPercent,omitempty" tf:"checks_failed_percent"`

	RoundTripTimeMs *float64 `json:"roundTripTimeMs,omitempty" tf:"round_trip_time_ms"`
}

type TCPConfigurationObservation struct {
}

type TCPConfigurationParameters struct {
	Port int64 `json:"port" tf:"port"`

	TraceRouteEnabled *bool `json:"traceRouteEnabled,omitempty" tf:"trace_route_enabled"`
}

type TestConfigurationObservation struct {
}

type TestConfigurationParameters struct {
	HTTPConfiguration []HTTPConfigurationParameters `json:"httpConfiguration,omitempty" tf:"http_configuration"`

	IcmpConfiguration []IcmpConfigurationParameters `json:"icmpConfiguration,omitempty" tf:"icmp_configuration"`

	Name string `json:"name" tf:"name"`

	PreferredIPVersion *string `json:"preferredIpVersion,omitempty" tf:"preferred_ip_version"`

	Protocol string `json:"protocol" tf:"protocol"`

	SuccessThreshold []SuccessThresholdParameters `json:"successThreshold,omitempty" tf:"success_threshold"`

	TCPConfiguration []TCPConfigurationParameters `json:"tcpConfiguration,omitempty" tf:"tcp_configuration"`

	TestFrequencyInSeconds *int64 `json:"testFrequencyInSeconds,omitempty" tf:"test_frequency_in_seconds"`
}

type TestGroupObservation struct {
}

type TestGroupParameters struct {
	DestinationEndpoints []string `json:"destinationEndpoints" tf:"destination_endpoints"`

	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`

	Name string `json:"name" tf:"name"`

	SourceEndpoints []string `json:"sourceEndpoints" tf:"source_endpoints"`

	TestConfigurationNames []string `json:"testConfigurationNames" tf:"test_configuration_names"`
}

// NetworkConnectionMonitorSpec defines the desired state of NetworkConnectionMonitor
type NetworkConnectionMonitorSpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       NetworkConnectionMonitorParameters `json:"forProvider"`
}

// NetworkConnectionMonitorStatus defines the observed state of NetworkConnectionMonitor.
type NetworkConnectionMonitorStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          NetworkConnectionMonitorObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// NetworkConnectionMonitor is the Schema for the NetworkConnectionMonitors API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azure}
type NetworkConnectionMonitor struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              NetworkConnectionMonitorSpec   `json:"spec"`
	Status            NetworkConnectionMonitorStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// NetworkConnectionMonitorList contains a list of NetworkConnectionMonitors
type NetworkConnectionMonitorList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []NetworkConnectionMonitor `json:"items"`
}

// Repository type metadata.
var (
	NetworkConnectionMonitorKind             = "NetworkConnectionMonitor"
	NetworkConnectionMonitorGroupKind        = schema.GroupKind{Group: Group, Kind: NetworkConnectionMonitorKind}.String()
	NetworkConnectionMonitorKindAPIVersion   = NetworkConnectionMonitorKind + "." + GroupVersion.String()
	NetworkConnectionMonitorGroupVersionKind = GroupVersion.WithKind(NetworkConnectionMonitorKind)
)

func init() {
	SchemeBuilder.Register(&NetworkConnectionMonitor{}, &NetworkConnectionMonitorList{})
}
