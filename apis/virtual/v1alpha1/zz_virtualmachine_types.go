/*
Copyright 2020 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
)

type AdditionalCapabilitiesObservation struct {
}

type AdditionalCapabilitiesParameters struct {

	// +kubebuilder:validation:Required
	UltraSsdEnabled bool `json:"ultraSsdEnabled" tf:"ultra_ssd_enabled"`
}

type AdditionalUnattendConfigObservation struct {
}

type AdditionalUnattendConfigParameters struct {

	// +kubebuilder:validation:Required
	Component string `json:"component" tf:"component"`

	// +kubebuilder:validation:Required
	Content string `json:"content" tf:"content"`

	// +kubebuilder:validation:Required
	Pass string `json:"pass" tf:"pass"`

	// +kubebuilder:validation:Required
	SettingName string `json:"settingName" tf:"setting_name"`
}

type BootDiagnosticsObservation struct {
}

type BootDiagnosticsParameters struct {

	// +kubebuilder:validation:Required
	Enabled bool `json:"enabled" tf:"enabled"`

	// +kubebuilder:validation:Required
	StorageURI string `json:"storageUri" tf:"storage_uri"`
}

type IdentityObservation struct {
	PrincipalID string `json:"principalId,omitempty" tf:"principal_id"`
}

type IdentityParameters struct {

	// +kubebuilder:validation:Optional
	IdentityIds []string `json:"identityIds,omitempty" tf:"identity_ids"`

	// +kubebuilder:validation:Required
	Type string `json:"type" tf:"type"`
}

type OsProfileLinuxConfigObservation struct {
}

type OsProfileLinuxConfigParameters struct {

	// +kubebuilder:validation:Required
	DisablePasswordAuthentication bool `json:"disablePasswordAuthentication" tf:"disable_password_authentication"`

	// +kubebuilder:validation:Optional
	SSHKeys []SSHKeysParameters `json:"sshKeys,omitempty" tf:"ssh_keys"`
}

type OsProfileObservation struct {
}

type OsProfileParameters struct {

	// +kubebuilder:validation:Optional
	AdminPassword *string `json:"adminPassword,omitempty" tf:"admin_password"`

	// +kubebuilder:validation:Required
	AdminUsername string `json:"adminUsername" tf:"admin_username"`

	// +kubebuilder:validation:Required
	ComputerName string `json:"computerName" tf:"computer_name"`

	// +kubebuilder:validation:Optional
	CustomData *string `json:"customData,omitempty" tf:"custom_data"`
}

type OsProfileSecretsObservation struct {
}

type OsProfileSecretsParameters struct {

	// +kubebuilder:validation:Required
	SourceVaultID string `json:"sourceVaultId" tf:"source_vault_id"`

	// +kubebuilder:validation:Optional
	VaultCertificates []VaultCertificatesParameters `json:"vaultCertificates,omitempty" tf:"vault_certificates"`
}

type OsProfileWindowsConfigObservation struct {
}

type OsProfileWindowsConfigParameters struct {

	// +kubebuilder:validation:Optional
	AdditionalUnattendConfig []AdditionalUnattendConfigParameters `json:"additionalUnattendConfig,omitempty" tf:"additional_unattend_config"`

	// +kubebuilder:validation:Optional
	EnableAutomaticUpgrades *bool `json:"enableAutomaticUpgrades,omitempty" tf:"enable_automatic_upgrades"`

	// +kubebuilder:validation:Optional
	ProvisionVMAgent *bool `json:"provisionVmAgent,omitempty" tf:"provision_vm_agent"`

	// +kubebuilder:validation:Optional
	Timezone *string `json:"timezone,omitempty" tf:"timezone"`

	// +kubebuilder:validation:Optional
	Winrm []WinrmParameters `json:"winrm,omitempty" tf:"winrm"`
}

type PlanObservation struct {
}

type PlanParameters struct {

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`

	// +kubebuilder:validation:Required
	Product string `json:"product" tf:"product"`

	// +kubebuilder:validation:Required
	Publisher string `json:"publisher" tf:"publisher"`
}

type SSHKeysObservation struct {
}

type SSHKeysParameters struct {

	// +kubebuilder:validation:Required
	KeyData string `json:"keyData" tf:"key_data"`

	// +kubebuilder:validation:Required
	Path string `json:"path" tf:"path"`
}

type StorageDataDiskObservation struct {
}

type StorageDataDiskParameters struct {

	// +kubebuilder:validation:Optional
	Caching *string `json:"caching,omitempty" tf:"caching"`

	// +kubebuilder:validation:Required
	CreateOption string `json:"createOption" tf:"create_option"`

	// +kubebuilder:validation:Optional
	DiskSizeGb *int64 `json:"diskSizeGb,omitempty" tf:"disk_size_gb"`

	// +kubebuilder:validation:Required
	Lun int64 `json:"lun" tf:"lun"`

	// +kubebuilder:validation:Optional
	ManagedDiskID *string `json:"managedDiskId,omitempty" tf:"managed_disk_id"`

	// +kubebuilder:validation:Optional
	ManagedDiskType *string `json:"managedDiskType,omitempty" tf:"managed_disk_type"`

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`

	// +kubebuilder:validation:Optional
	VhdURI *string `json:"vhdUri,omitempty" tf:"vhd_uri"`

	// +kubebuilder:validation:Optional
	WriteAcceleratorEnabled *bool `json:"writeAcceleratorEnabled,omitempty" tf:"write_accelerator_enabled"`
}

type StorageImageReferenceObservation struct {
}

type StorageImageReferenceParameters struct {

	// +kubebuilder:validation:Optional
	ID *string `json:"id,omitempty" tf:"id"`

	// +kubebuilder:validation:Optional
	Offer *string `json:"offer,omitempty" tf:"offer"`

	// +kubebuilder:validation:Optional
	Publisher *string `json:"publisher,omitempty" tf:"publisher"`

	// +kubebuilder:validation:Optional
	Sku *string `json:"sku,omitempty" tf:"sku"`

	// +kubebuilder:validation:Optional
	Version *string `json:"version,omitempty" tf:"version"`
}

type StorageOsDiskObservation struct {
}

type StorageOsDiskParameters struct {

	// +kubebuilder:validation:Optional
	Caching *string `json:"caching,omitempty" tf:"caching"`

	// +kubebuilder:validation:Required
	CreateOption string `json:"createOption" tf:"create_option"`

	// +kubebuilder:validation:Optional
	DiskSizeGb *int64 `json:"diskSizeGb,omitempty" tf:"disk_size_gb"`

	// +kubebuilder:validation:Optional
	ImageURI *string `json:"imageUri,omitempty" tf:"image_uri"`

	// +kubebuilder:validation:Optional
	ManagedDiskID *string `json:"managedDiskId,omitempty" tf:"managed_disk_id"`

	// +kubebuilder:validation:Optional
	ManagedDiskType *string `json:"managedDiskType,omitempty" tf:"managed_disk_type"`

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`

	// +kubebuilder:validation:Optional
	OsType *string `json:"osType,omitempty" tf:"os_type"`

	// +kubebuilder:validation:Optional
	VhdURI *string `json:"vhdUri,omitempty" tf:"vhd_uri"`

	// +kubebuilder:validation:Optional
	WriteAcceleratorEnabled *bool `json:"writeAcceleratorEnabled,omitempty" tf:"write_accelerator_enabled"`
}

type VaultCertificatesObservation struct {
}

type VaultCertificatesParameters struct {

	// +kubebuilder:validation:Optional
	CertificateStore *string `json:"certificateStore,omitempty" tf:"certificate_store"`

	// +kubebuilder:validation:Required
	CertificateURL string `json:"certificateUrl" tf:"certificate_url"`
}

type VirtualMachineObservation struct {
}

type VirtualMachineParameters struct {

	// +kubebuilder:validation:Optional
	AdditionalCapabilities []AdditionalCapabilitiesParameters `json:"additionalCapabilities,omitempty" tf:"additional_capabilities"`

	// +kubebuilder:validation:Optional
	AvailabilitySetID *string `json:"availabilitySetId,omitempty" tf:"availability_set_id"`

	// +kubebuilder:validation:Optional
	BootDiagnostics []BootDiagnosticsParameters `json:"bootDiagnostics,omitempty" tf:"boot_diagnostics"`

	// +kubebuilder:validation:Optional
	DeleteDataDisksOnTermination *bool `json:"deleteDataDisksOnTermination,omitempty" tf:"delete_data_disks_on_termination"`

	// +kubebuilder:validation:Optional
	DeleteOsDiskOnTermination *bool `json:"deleteOsDiskOnTermination,omitempty" tf:"delete_os_disk_on_termination"`

	// +kubebuilder:validation:Optional
	Identity []IdentityParameters `json:"identity,omitempty" tf:"identity"`

	// +kubebuilder:validation:Optional
	LicenseType *string `json:"licenseType,omitempty" tf:"license_type"`

	// +kubebuilder:validation:Required
	Location string `json:"location" tf:"location"`

	// +kubebuilder:validation:Required
	Name string `json:"name" tf:"name"`

	// +kubebuilder:validation:Required
	NetworkInterfaceIds []string `json:"networkInterfaceIds" tf:"network_interface_ids"`

	// +kubebuilder:validation:Optional
	OsProfile []OsProfileParameters `json:"osProfile,omitempty" tf:"os_profile"`

	// +kubebuilder:validation:Optional
	OsProfileLinuxConfig []OsProfileLinuxConfigParameters `json:"osProfileLinuxConfig,omitempty" tf:"os_profile_linux_config"`

	// +kubebuilder:validation:Optional
	OsProfileSecrets []OsProfileSecretsParameters `json:"osProfileSecrets,omitempty" tf:"os_profile_secrets"`

	// +kubebuilder:validation:Optional
	OsProfileWindowsConfig []OsProfileWindowsConfigParameters `json:"osProfileWindowsConfig,omitempty" tf:"os_profile_windows_config"`

	// +kubebuilder:validation:Optional
	Plan []PlanParameters `json:"plan,omitempty" tf:"plan"`

	// +kubebuilder:validation:Optional
	PrimaryNetworkInterfaceID *string `json:"primaryNetworkInterfaceId,omitempty" tf:"primary_network_interface_id"`

	// +kubebuilder:validation:Optional
	ProximityPlacementGroupID *string `json:"proximityPlacementGroupId,omitempty" tf:"proximity_placement_group_id"`

	// +kubebuilder:validation:Required
	ResourceGroupName string `json:"resourceGroupName" tf:"resource_group_name"`

	// +kubebuilder:validation:Optional
	StorageDataDisk []StorageDataDiskParameters `json:"storageDataDisk,omitempty" tf:"storage_data_disk"`

	// +kubebuilder:validation:Optional
	StorageImageReference []StorageImageReferenceParameters `json:"storageImageReference,omitempty" tf:"storage_image_reference"`

	// +kubebuilder:validation:Required
	StorageOsDisk []StorageOsDiskParameters `json:"storageOsDisk" tf:"storage_os_disk"`

	// +kubebuilder:validation:Optional
	Tags map[string]string `json:"tags,omitempty" tf:"tags"`

	// +kubebuilder:validation:Required
	VMSize string `json:"vmSize" tf:"vm_size"`

	// +kubebuilder:validation:Optional
	Zones []string `json:"zones,omitempty" tf:"zones"`
}

type WinrmObservation struct {
}

type WinrmParameters struct {

	// +kubebuilder:validation:Optional
	CertificateURL *string `json:"certificateUrl,omitempty" tf:"certificate_url"`

	// +kubebuilder:validation:Required
	Protocol string `json:"protocol" tf:"protocol"`
}

// VirtualMachineSpec defines the desired state of VirtualMachine
type VirtualMachineSpec struct {
	v1.ResourceSpec `json:",inline"`
	ForProvider     VirtualMachineParameters `json:"forProvider"`
}

// VirtualMachineStatus defines the observed state of VirtualMachine.
type VirtualMachineStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        VirtualMachineObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// VirtualMachine is the Schema for the VirtualMachines API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azure}
type VirtualMachine struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              VirtualMachineSpec   `json:"spec"`
	Status            VirtualMachineStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// VirtualMachineList contains a list of VirtualMachines
type VirtualMachineList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []VirtualMachine `json:"items"`
}

// Repository type metadata.
var (
	VirtualMachineKind             = "VirtualMachine"
	VirtualMachineGroupKind        = schema.GroupKind{Group: Group, Kind: VirtualMachineKind}.String()
	VirtualMachineKindAPIVersion   = VirtualMachineKind + "." + GroupVersion.String()
	VirtualMachineGroupVersionKind = GroupVersion.WithKind(VirtualMachineKind)
)

func init() {
	SchemeBuilder.Register(&VirtualMachine{}, &VirtualMachineList{})
}
