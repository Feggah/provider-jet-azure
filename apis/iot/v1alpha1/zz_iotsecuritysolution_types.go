/*
Copyright 2020 The Crossplane Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by terrajet. DO NOT EDIT.

package v1alpha1

import (
	xpv1 "github.com/crossplane/crossplane-runtime/apis/common/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"
)

type IotSecuritySolutionObservation struct {
}

type IotSecuritySolutionParameters struct {
	DisplayName string `json:"displayName" tf:"display_name"`

	Enabled *bool `json:"enabled,omitempty" tf:"enabled"`

	EventsToExport []string `json:"eventsToExport,omitempty" tf:"events_to_export"`

	IothubIds []string `json:"iothubIds" tf:"iothub_ids"`

	Location string `json:"location" tf:"location"`

	LogAnalyticsWorkspaceID *string `json:"logAnalyticsWorkspaceId,omitempty" tf:"log_analytics_workspace_id"`

	LogUnmaskedIpsEnabled *bool `json:"logUnmaskedIpsEnabled,omitempty" tf:"log_unmasked_ips_enabled"`

	Name string `json:"name" tf:"name"`

	QueryForResources *string `json:"queryForResources,omitempty" tf:"query_for_resources"`

	QuerySubscriptionIds []string `json:"querySubscriptionIds,omitempty" tf:"query_subscription_ids"`

	RecommendationsEnabled []RecommendationsEnabledParameters `json:"recommendationsEnabled,omitempty" tf:"recommendations_enabled"`

	ResourceGroupName string `json:"resourceGroupName" tf:"resource_group_name"`

	Tags map[string]string `json:"tags,omitempty" tf:"tags"`
}

type RecommendationsEnabledObservation struct {
}

type RecommendationsEnabledParameters struct {
	AcrAuthentication *bool `json:"acrAuthentication,omitempty" tf:"acr_authentication"`

	AgentSendUnutilizedMsg *bool `json:"agentSendUnutilizedMsg,omitempty" tf:"agent_send_unutilized_msg"`

	Baseline *bool `json:"baseline,omitempty" tf:"baseline"`

	EdgeHubMemOptimize *bool `json:"edgeHubMemOptimize,omitempty" tf:"edge_hub_mem_optimize"`

	EdgeLoggingOption *bool `json:"edgeLoggingOption,omitempty" tf:"edge_logging_option"`

	IPFilterDenyAll *bool `json:"ipFilterDenyAll,omitempty" tf:"ip_filter_deny_all"`

	IPFilterPermissiveRule *bool `json:"ipFilterPermissiveRule,omitempty" tf:"ip_filter_permissive_rule"`

	InconsistentModuleSettings *bool `json:"inconsistentModuleSettings,omitempty" tf:"inconsistent_module_settings"`

	InstallAgent *bool `json:"installAgent,omitempty" tf:"install_agent"`

	OpenPorts *bool `json:"openPorts,omitempty" tf:"open_ports"`

	PermissiveFirewallPolicy *bool `json:"permissiveFirewallPolicy,omitempty" tf:"permissive_firewall_policy"`

	PermissiveInputFirewallRules *bool `json:"permissiveInputFirewallRules,omitempty" tf:"permissive_input_firewall_rules"`

	PermissiveOutputFirewallRules *bool `json:"permissiveOutputFirewallRules,omitempty" tf:"permissive_output_firewall_rules"`

	PrivilegedDockerOptions *bool `json:"privilegedDockerOptions,omitempty" tf:"privileged_docker_options"`

	SharedCredentials *bool `json:"sharedCredentials,omitempty" tf:"shared_credentials"`

	VulnerableTLSCipherSuite *bool `json:"vulnerableTlsCipherSuite,omitempty" tf:"vulnerable_tls_cipher_suite"`
}

// IotSecuritySolutionSpec defines the desired state of IotSecuritySolution
type IotSecuritySolutionSpec struct {
	xpv1.ResourceSpec `json:",inline"`
	ForProvider       IotSecuritySolutionParameters `json:"forProvider"`
}

// IotSecuritySolutionStatus defines the observed state of IotSecuritySolution.
type IotSecuritySolutionStatus struct {
	xpv1.ResourceStatus `json:",inline"`
	AtProvider          IotSecuritySolutionObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true

// IotSecuritySolution is the Schema for the IotSecuritySolutions API
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Cluster,categories={crossplane,managed,azure}
type IotSecuritySolution struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              IotSecuritySolutionSpec   `json:"spec"`
	Status            IotSecuritySolutionStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// IotSecuritySolutionList contains a list of IotSecuritySolutions
type IotSecuritySolutionList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []IotSecuritySolution `json:"items"`
}

// Repository type metadata.
var (
	IotSecuritySolutionKind             = "IotSecuritySolution"
	IotSecuritySolutionGroupKind        = schema.GroupKind{Group: Group, Kind: IotSecuritySolutionKind}.String()
	IotSecuritySolutionKindAPIVersion   = IotSecuritySolutionKind + "." + GroupVersion.String()
	IotSecuritySolutionGroupVersionKind = GroupVersion.WithKind(IotSecuritySolutionKind)
)

func init() {
	SchemeBuilder.Register(&IotSecuritySolution{}, &IotSecuritySolutionList{})
}
